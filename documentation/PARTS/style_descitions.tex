\section{Styleguide}

\subsection{General Guides}
As I'm sure the list following in section~\ref{sub:decisions} will be
incomplete for some time to come, as some situations won't occur or are not
foreseen at the time of writing. As it would be too much effort to address every
edge case I present the following compromise:

Most situations handling codestyle problems are handled in
section~\ref{sub:descitions}. If for some reason a situation is not handled
there, please refer to the Google Python Style Guide. 
% \url{https://google.github.io/styleguide/pyguide.html}
In the rare case that something is not handled \emph{there}, please refer to the
official PEP8 Style Guide written by Guido van Rossum.
Please note, that neither the style guide provided by Google, not the PEP8 Guide
overrule the decisions made in this style guide.

\subsection{Tools}
Following will list the tools used to help in keeping the code clean
and uniform:

\subsubsection{Linter}
Currently, the \textbf{flake8} linter is used. The repository also provides a
flake8rc which configures the linter according to the requirements. To run the
linter, simply run it on the source directory using \cli{flake8 src/}. I also
recommend integrating it into your text editor or IDE to run it automatically
on the edited file or on the press of a button. 

\subsubsection{Typechecking}
As typehints are greatly encouraged in the project, I recomend to
use \textbf{mypy} when modifying the code. In this case, no configuration is
needed and you can simply run \cli{mypy src/} on the source directory to check
for any type incompatibilities. This can also be integrated into your
text editor or IDE.

\subsection{Style Decisions}\label{sub:descitions}
Now, on to how the code actually should look.

\subsubsection{Project Layout}
The rough layout of the project looks like this: 

\begin{figure}[!ht]
    % \centering
    \dirtree{%
    .1 /.
        .2 docs.
        .2 src.
            .3 pipetex.
                .4 \_\_init\_\_.py.
                .4 main.py.
                .4 pipeline.py.
                .4 various\_utils.py\DTcomment{This is just an example module}.
        .2 tests.
    }
    \caption{Directory Structure}
\end{figure}

Ideally, only new modules have to be introduced to the codebase and no new
packages.

\newpage

\subsubsection{Naming}
Naming conventions are described in this section. Following, functions and
methods are referred to as functions. 

\paragraph{Modules} \textbf{\textit{module\_name.py}} \\
Module names follow the snake\_case convention. Uppercase letters, numbers and
symbols other than the underscore are strongly discouraged.

\paragraph{Classes} \textbf{\textit{ClassName.py}}  \\
Class names follow the PascalCase convention. Only upper- and lowercase letters
are allowed in the class name. Numbers technically work but are discouraged.

\paragraph{functions} \textbf{\textit{function\_name}} \\
Functions follow the snake\_case convention. To signify a function is internal
(private or protected) add a single underscore ( \_ ) at the beginning of the
function name. Double underscores (so called {\glqq dunder\grqq}, \_\_) are a
way of making it private to the class, however it impacts readability and
testability without making the function {\glqq true private\grqq}. Prefer
single underscores and use a linter, which will flag private member
access\footnote{Some code completion engines also support the single underscore
notation, as members with a leading underscore won't be shown in the code
completion preview}.

Unittests should follow the function naming convention. Each test should start
with {\glqq test\_\grqq}\footnote{I remember some frameworks force this convention, 
some do not. As it is technically possible to use different frameworks in the same
project I decided to enforce this naming style.} followed by the name of the
function that is tested. If an error condition is tested, a short string in
camelCase describing the error should follow the function name. See an example
below:

\codeexample
{Example Test Function}
{92}
{93}
{../tests/test_compilation_operations.py}

\codeexample
{Example Test Function Testing Error}
{106}
{107}
{../tests/test_compilation_operations.py}

\paragraph{Variables} \textbf{\textit{variable\_name}} \\
Variables names follow the snake\_case conventions. To signify a class member
is internal add a single underscore to the beginning of the name. In case of
a constant, the name should be written in ALL\_CAPS.

\paragraph{Names to avoid} 
Please avoid single character names like $a = 4$ or $b = function()$. Inside
for loops it is common practice to use counting variables, for example $i, j,
k$ etc. This is accepted as it is commonly known. Dashes ( - ) should not be
used in module-, class-, function- or variablenames. Please also avoid using
slurs, political statements / abbreviations or any other offensive language.

\subsubsection{Docstrings}\label{ssub:docstrings}
Docstrings should be added at the top of modules, after the class name and
after a function declaration. In general, all docstrngs follow the same scheme.
Use three double quotes (" $\mapsto$ """) to start and end a docstring. 
The first line of every docstring should contain a brief summary of the module /
class / function it documents followed by a blank line. If the author wants to
write more (which is encouraged) this can be done after the blank line.
The docstring should not exceed the 80 character line.

This is the basic way to write a docstring. What follows next depends on what the
docstring documents.

\paragraph{Module Docstrings} Module docstrings contain the author and date of
creation of the module. The contents of the docstring should describe what belongs
into the module and how to use it.

Example docstring:

\codeexample
{Example Module Docstring}
{1}
{9}
{../src/pipetex/operations.py}

\paragraph{Class Docstrings} Class docstrings should contain a list of public
attributes after the summary. If you think its necessary, include a small 
example on how the class would commonly be used. After this the reader should
find a list of public attributes. The docstring should be indented one level
deeper than the classname.

Example docstring

\codeexample
{Example Class Docstring}
{26}
{42}
{../src/pipetex/pipeline.py}

\paragraph{Function Docstrings}\footnote{This also applies to methods. Function
and method are used interchangeably.} Function docstrings should describe all
side effects that can occur during the execution (logging is not considered a
side effect). After the summary, the docstring should include:

\subparagraph{Args:} A short list describing each argument passed to the
function.  What is it, how is it used, why is it there. If the argument is a
default argument, describe what it default value is. \verb|self| and \verb|cls|
variables do not need to be documented. If the function receives no arguments,
this field is omitted.

\subparagraph{Returns:} A short description of the return value of the
function.  In most cases, this is the same for all functions, as monadic error
handling is used in the project. If the return value is a variable, use the
variable name to list it. Else, use its type. If the function does not return
anything, this field is omitted.

\subparagraph{Raises:} A short description of which type of error the function
raises and when. If the error is a \verb|InternalException|, document which 
\verb|severity_level| is / are used. If no exceptions are raised, this field is
omitted.

Example docstring:

\codeexample
{Example Function Docstring}
{27}
{52}
{../src/pipetex/operations.py}

